# 49. 매개변수가 유효한지 검사하라

<br>

### 오류는 가능한 빨리 잡아야 한다

- 메서드와 생성자 대부분은 입력 매개변수와 값이 특정 조건을 만족해야 함
    - index는 음수이면 안됨, 객체 참조는 null이면 안됨
- 이런 제약은 문서화해야하고 메서드 몸체가 시작되기 전에 검사해야 함


### 매개변수 검사를 제대로 하지 못한다면?
- 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있음
- 메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있음 ( 나쁨 )
- 메서드가 문제없이 수행됐지만 어떤 객체를 이상한 상태로 만들어놔서 미래의 알 수 없는 시점에 오류 발생 ( 최악 ) 

<br>

- 즉, 매개변수 검사에 실패하면 실패 원자성을 깨뜨림
    - **실패 원자성?** *호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다*

### public, protected 메서드는 예외를 문서화하라 

- 메서드가 매개변수 값이 잘못된 경우 던지는 예외를 문서화 해야함
    - `@throws` 자바독 태그 이용
        ```java
        /**
        * @param value (이름은 공백이나 빈 값이면 안된다.)
        * @throws IllegalArgumentException 이름이 공백이나 빈 값일 경우 발생한다.
        */
        public Name(String value) {
            validateBlank(value);
            this.value = value;
        }
        ```

### private 메서드는 assert를 사용하라

- assert가 머임?
    - `assert 조건식` 의 모양을 띠고있음. (JDK 1.4부터 추가)
    - 자신이 단언한 조건이 무조건 참이라고 선언해야함
    
```java
void doMethod(String title, int count){
    assert title != null;
    assert count >= 0;
    // doMethod...
}
```
- assert를 사용하면 유효성 검사와 다른 점
    - 만약 실패할 경우 JVM이 `AssertionError`를 발생시킴
    - 대부분 런타임에 아무런 효과도, 아무런 성능 저하도 없다. 

### 몸체 실행 전 매개변수 유효성 검사를 하라의 **예외상황**
- 유효성 검사 비용이 너무 높거나 실용적이지 않을 때
- 계산 과정에서 암묵적으로 검사가 수행될 때
    - 예 ) Collections.sort(List)
        - 정렬 과정에서 비교할 때 상호 비교될 수 있는 타입인지 확인. 만약 아닐 시 `ClassCastException`을 던짐
        - 비교하기 앞서 리스트 안의 모든 객체의 상호 비교 가능성을 검사해봤자 실용성 X
- 때때로 API 문서에서 던지기로 한 예외와 다를 수 있기 때문에 예외 번역 관용구를 사용하여 API 문서에 기재된 예외로 번역해 주는 것이 필요
```java
try{
    에러발생 코드
} catch (A 에러) { // A 예외를 캐치해서 B 예외로 처리 
    throw new B 에러
}
```

### 유용한 예외처리 메서드
- `java.util.Objects.requireNonNull` : 자바 7 이후에 추가된 null 검사 해주는 메서드
- 자바 9 이후 checkFromIndexSize, checkFromToIndex, checkIndex 메서드가 추가됐지만 null 검사만큼 유연하지 못함 (예외 메시지 지정 불가, 리스트와 배열 전용, 닫힌 범위는 다루지 못함)

### 결론
✅ **메서드나 생성자를 작성할 때 제약사항에 대해 메서드 코드 시작부분에서 명시적으로 검사해야 한다.**